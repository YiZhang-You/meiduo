# 1、商品部分

## 1.1 数据表设计

在电商中对于商品，有两个重要的概念：**SPU**和**SKU**

- **SPU = Standard Product Unit （标准产品单位）**

  SPU是商品信息聚合的最小单位，是一组可服用、易检索的标准化信息的集合，该集合描述了一个产品的特性。

  通俗的讲，属性值、特性相同的商品就可以称为一个SPU。

  例如:

  iPhone X 就是一个SPU，与商家、颜色、款式、规格、套餐等都无关。()

- **SKU = Stock Keeping Unit （库存量单位）**

  SKU即库存进出计量的单位，可以是以件、盒、托盘等为单位，是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。

  例如：

  iPhone X 全网通黑色256G 就是一个SKU，表示了具体的规格、颜色等信息。(具体)

### 1.1.1 表结构

商品数据表结构

![输入图片说明](https://images.gitee.com/uploads/images/2021/0723/150039_ca78e1ab_7998440.png "13.png")

首页广告数据表结构

![输入图片说明](https://images.gitee.com/uploads/images/2021/0723/150048_b3378fa3_7998440.png "14.png")

### 1.1.2 创建二个app应用

```python
(Vrmduo) G:\YLG\项目\meiduo\meiduo_mall\meiduo_mall\apps>python ../../manage.py startapp goods  # 商品
(Vrmduo) G:\YLG\项目\meiduo\meiduo_mall\meiduo_mall\apps>python ../../manage.py startapp contents  # 广告内容
```

```python
在settings中配置
```

### 1.1.3 数据库模型类

goods：商品

```python
from django.db import models

from meiduo_mall.utils.models import BaseModel


class GoodsCategory(BaseModel):
    """
    商品类别
    """
    name = models.CharField(max_length=10, verbose_name='名称')
    parent = models.ForeignKey('self', null=True, blank=True, on_delete=models.CASCADE, verbose_name='父类别')

    class Meta:
        db_table = 'tb_goods_category'
        verbose_name = '商品类别'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class GoodsChannel(BaseModel):
    """
    商品频道
    """
    group_id = models.IntegerField(verbose_name='组号')
    category = models.ForeignKey(GoodsCategory, on_delete=models.CASCADE, verbose_name='顶级商品类别')
    url = models.CharField(max_length=50, verbose_name='频道页面链接')
    sequence = models.IntegerField(verbose_name='组内顺序')

    class Meta:
        db_table = 'tb_goods_channel'
        verbose_name = '商品频道'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.category.name


class Brand(BaseModel):
    """
    品牌
    """
    name = models.CharField(max_length=20, verbose_name='名称')
    logo = models.ImageField(verbose_name='Logo图片')
    first_letter = models.CharField(max_length=1, verbose_name='品牌首字母')

    class Meta:
        db_table = 'tb_brand'
        verbose_name = '品牌'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class Goods(BaseModel):
    """
    商品SPU
    """
    name = models.CharField(max_length=50, verbose_name='名称')
    brand = models.ForeignKey(Brand, on_delete=models.PROTECT, verbose_name='品牌')
    category1 = models.ForeignKey(GoodsCategory, on_delete=models.PROTECT, related_name='cat1_goods', verbose_name='一级类别')
    category2 = models.ForeignKey(GoodsCategory, on_delete=models.PROTECT, related_name='cat2_goods', verbose_name='二级类别')
    category3 = models.ForeignKey(GoodsCategory, on_delete=models.PROTECT, related_name='cat3_goods', verbose_name='三级类别')
    sales = models.IntegerField(default=0, verbose_name='销量')
    comments = models.IntegerField(default=0, verbose_name='评价数')

    class Meta:
        db_table = 'tb_goods'
        verbose_name = '商品'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class GoodsSpecification(BaseModel):
    """
    商品规格
    """
    goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name='商品')
    name = models.CharField(max_length=20, verbose_name='规格名称')

    class Meta:
        db_table = 'tb_goods_specification'
        verbose_name = '商品规格'
        verbose_name_plural = verbose_name

    def __str__(self):
        return '%s: %s' % (self.goods.name, self.name)


class SpecificationOption(BaseModel):
    """
    规格选项
    """
    spec = models.ForeignKey(GoodsSpecification, on_delete=models.CASCADE, verbose_name='规格')
    value = models.CharField(max_length=20, verbose_name='选项值')

    class Meta:
        db_table = 'tb_specification_option'
        verbose_name = '规格选项'
        verbose_name_plural = verbose_name

    def __str__(self):
        return '%s - %s' % (self.spec, self.value)


class SKU(BaseModel):
    """
    商品SKU
    """
    name = models.CharField(max_length=50, verbose_name='名称')
    caption = models.CharField(max_length=100, verbose_name='副标题')
    goods = models.ForeignKey(Goods, on_delete=models.CASCADE, verbose_name='商品')
    category = models.ForeignKey(GoodsCategory, on_delete=models.PROTECT, verbose_name='从属类别')
    price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='单价')
    cost_price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='进价')
    market_price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name='市场价')
    stock = models.IntegerField(default=0, verbose_name='库存')
    sales = models.IntegerField(default=0, verbose_name='销量')
    comments = models.IntegerField(default=0, verbose_name='评价数')
    is_launched = models.BooleanField(default=True, verbose_name='是否上架销售')
    default_image_url = models.CharField(max_length=200, default='', null=True, blank=True, verbose_name='默认图片')

    class Meta:
        db_table = 'tb_sku'
        verbose_name = '商品SKU'
        verbose_name_plural = verbose_name

    def __str__(self):
        return '%s: %s' % (self.id, self.name)


class SKUImage(BaseModel):
    """
    SKU图片
    """
    sku = models.ForeignKey(SKU, on_delete=models.CASCADE, verbose_name='sku')
    image = models.ImageField(verbose_name='图片')

    class Meta:
        db_table = 'tb_sku_image'
        verbose_name = 'SKU图片'
        verbose_name_plural = verbose_name

    def __str__(self):
        return '%s %s' % (self.sku.name, self.id)


class SKUSpecification(BaseModel):
    """
    SKU具体规格
    """
    sku = models.ForeignKey(SKU, on_delete=models.CASCADE, verbose_name='sku')
    spec = models.ForeignKey(GoodsSpecification, on_delete=models.PROTECT, verbose_name='规格名称')
    option = models.ForeignKey(SpecificationOption, on_delete=models.PROTECT, verbose_name='规格值')

    class Meta:
        db_table = 'tb_sku_specification'
        verbose_name = 'SKU规格'
        verbose_name_plural = verbose_name

    def __str__(self):
        return '%s: %s - %s' % (self.sku, self.spec.name, self.option.value)
```

contents : 广告内容

```python
from django.db import models

from meiduo_mall.utils.models import BaseModel


class ContentCategory(BaseModel):
    """
    广告内容类别
    """
    name = models.CharField(max_length=50, verbose_name='名称')
    key = models.CharField(max_length=50, verbose_name='类别键名')

    class Meta:
        db_table = 'tb_content_category'
        verbose_name = '广告内容类别'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class Content(BaseModel):
    """
    广告内容
    """
    category = models.ForeignKey(ContentCategory, on_delete=models.PROTECT, verbose_name='类别')
    title = models.CharField(max_length=100, verbose_name='标题')
    url = models.CharField(max_length=300, verbose_name='内容链接')
    image = models.ImageField(null=True, blank=True, verbose_name='图片')
    text = models.TextField(null=True, blank=True, verbose_name='内容')
    sequence = models.IntegerField(verbose_name='排序')
    status = models.BooleanField(default=True, verbose_name='是否展示')

    class Meta:
        db_table = 'tb_content'
        verbose_name = '广告内容'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.category.name + ': ' + self.title
```

### 1.1.4 迁移

```python
(Vrmduo) G:\YLG\项目\meiduo\meiduo_mall\meiduo_mall\apps>python ../../manage.py makemigrations
(Vrmduo) G:\YLG\项目\meiduo\meiduo_mall\meiduo_mall\apps>python ../../manage.py migrate
    
在settings中注册
配置urls.py， 和主路由
```



## 1.2 FastDFS分布式文件系统



**设置ubantu的固定Ip**:https://blog.csdn.net/qyf__123/article/details/84143913



### 1.2.1 什么是FastDFS

FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。

FastDFS 架构包括 **Tracker server** 和 **Storage server**。客户端请求 Tracker server 进行文 件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

- **Tracker server** 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些 策略找到 Storage server 提供文件上传服务。可以将 tracker 称为**追踪服务器**或**调度服务器**。
- **Storage server** 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将 storage 称为**存储服务器**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0723/150142_a023f0e0_7998440.png "16.png")

Django上传图片请求 --> 客户端 --> 调度服务器（查找空闲的storage） --> 找到后返回给客户端ip地址 --> 客户端向storage发生请求存储 --> 成功后会返回一个file_id



服务端两个角色:

- **Tracker**: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
- **Storage**: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。



## 1.3 Docker的使用

```
docker是一个开源的软件部署解决方案
docker也是轻量级的应用容器框架
docker可以打包、发布、运行任何的应用。
```

```
https://www.docker.org.cn/index.html  # 中文网
```

查看安装使用教程

安装好FastDFS和Docker后

## 1.4 FastDFS客户端与自定义文件存储系统

我们在meiduo_mall/utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下

```python
from django.conf import settings
from django.core.files.storage import Storage
from django.utils.deconstruct import deconstructible
from fdfs_client.client import Fdfs_client


@deconstructible
class FastDFSStorage(Storage):
    def __init__(self, base_url=None, client_conf=None):
        """
        初始化
        :param base_url: 用于构造图片完整路径使用，图片服务器的域名
        :param client_conf: FastDFS客户端配置文件的路径
        """
        if base_url is None:
            base_url = settings.FDFS_URL
        self.base_url = base_url
        if client_conf is None:
            client_conf = settings.FDFS_CLIENT_CONF
        self.client_conf = client_conf

    def _open(self, name, mode='rb'):
        """
        用不到打开文件，所以省略
        """
        pass

    def _save(self, name, content):
        """
        在FastDFS中保存文件
        :param name: 传入的文件名
        :param content: 文件内容
        :return: 保存到数据库中的FastDFS的文件名
        """
        client = Fdfs_client(self.client_conf)
        ret = client.upload_by_buffer(content.read())
        if ret.get("Status") != "Upload successed.":
            raise Exception("upload file failed")
        file_name = ret.get("Remote file_id")
        return file_name

    def url(self, name):
        """
        返回文件的完整URL路径
        :param name: 数据库中保存的文件名
        :return: 完整的URL
        """
        return self.base_url + name

    def exists(self, name):
        """
        判断文件是否存在，FastDFS可以自行解决文件的重名问题
        所以此处返回False，告诉Django上传的都是新文件
        :param name:  文件名
        :return: False
        """
        return False
```

在Django配置中设置自定义文件存储类

在settings/dev.py文件中添加设置

```python
# django文件存储
DEFAULT_FILE_STORAGE = 'meiduo_mall.utils.fastdfs.fdfs_storage.FastDFSStorage'

# FastDFS
FDFS_URL = 'http://image.meiduo.site:8888/'  
FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf')
```



以后要用的话直接把文件夹fastdfs拉过去就可以了，直接改settings中的配置就可以，还要更改fastdfs文件夹下client.conf配置

```python
# the base path to store log files(日志文件存放的位置)
base_path=/home/bee/dockerfile

# tracker_server can ocur more than once, and tracker_server format is
#  "host:port", host can be hostname or ip address（服务器ip）
tracker_server=192.168.216.135:22122
```



## 1.5 CKEditor富文本编辑器

1. 安装

```shell
pip install django-ckeditor
```

2. 添加应用

在settings中的INSTALLED_APPS中添加注册

```python
INSTALLED_APPS = [
    ...
    'ckeditor',  # 富文本编辑器
    'ckeditor_uploader',  # 富文本编辑器上传图片模块
    ...
]
```

3. 添加CKEditor设置

在settings/dev.py中添加

```python
# 富文本编辑器ckeditor配置
CKEDITOR_CONFIGS = {
    'default': {
        'toolbar': 'full',  # 工具条功能,需要显示的富文本主键
        'height': 300,  # 编辑器高度
        # 'width': 300,  # 编辑器宽
    },
}
CKEDITOR_UPLOAD_PATH = ''  # 上传图片保存路径，使用了FastDFS，所以此处设为''
```

4. 添加ckeditor路由

在总路由中添加

```python
url(r'^ckeditor/', include('ckeditor_uploader.urls')),
```

5. 为模型类添加字段

ckeditor提供了两种类型的Django模型类字段

- `ckeditor.fields.RichTextField` 不支持上传文件的富文本字段
- `ckeditor_uploader.fields.RichTextUploadingField` 支持上传文件的富文本字段

在商品模型类（SPU）中，要保存商品的详细介绍、包装信息、售后服务，这三个字段需要作为富文本字段

```python
from ckeditor.fields import RichTextField
from ckeditor_uploader.fields import RichTextUploadingField

class Goods(BaseModel):
    """
    商品SPU
    """
    # 下载富文本第三方后才可以使用的
    desc_detail = RichTextUploadingField(default='', verbose_name='详细介绍')
    desc_pack = RichTextField(default='', verbose_name='包装信息')
    desc_service = RichTextUploadingField(default='', verbose_name='售后服务')
```

```
迁移文件
makemigrations
migrate
```



### 修改Bug(上传到FastDFS中会出现问题)

我们将通过Django上传的图片保存到了FastDFS中，而保存在FastDFS中的文件名没有后缀名，ckeditor在处理上传后的文件名按照有后缀名来处理，所以会出现bug错误(会出现下标越界的问题)

**修正方法**

找到虚拟环境目录中的ckeditor_uploader/views.py文件，如

```shell
~/.virtualenvs/meiduo/lib/python3.5/site-packages/ckeditor_uploader/views.py
```

将第95行代码修改如下：

```python
if len(str(saved_path).split('.')) > 1:  # 添加的
 if(str(saved_path).split('.')[1].lower() != 'gif'):
 self._create_thumbnail_if_needed(backend, saved_path)
```

![输入图片说明](https://images.gitee.com/uploads/images/2021/0723/150255_c9e82d80_7998440.png "17.png")



## 1.6 创建超级用户添加测试数据

```python
python manage.py createsuperuser

admin
123456abc
```

添加测试数据

### 1.6.1 在admin中注册模型类

在广告内容contents应用的admin.py中注册模型类

```python
http://127.0.0.1:8000/admin  # 注册后登录后台就可以看见
```

```python
from django.contrib import admin

from . import models


admin.site.register(models.ContentCategory)  # 添加到admin中
admin.site.register(models.Content)
```

在商品goods应用的admin.py中注册商品模型类

```python
from django.contrib import admin

from . import models


admin.site.register(models.GoodsCategory)
admin.site.register(models.GoodsChannel)
admin.site.register(models.Goods)
admin.site.register(models.Brand)
admin.site.register(models.GoodsSpecification)
admin.site.register(models.SpecificationOption)
admin.site.register(models.SKU)
admin.site.register(models.SKUSpecification)
admin.site.register(models.SKUImage)
```



添加网站的图片

拿到data.tar.gz（里面是压缩的图片）

```
cd /var
cd fdfs/
cd storage/
sudo rm -rf data/  # 删除原来的data,换成新的data
sudo cp ~/Desktop/data.tar.gz ./
sudo tar -zxvf data.tar.gz   #解压
ls
```

添加11个表的sql数据

把goods_data.sql文件放到桌面

```python
root@bee-virtual-machine:/home/bee/桌面# mysql -uyyz -p meiduo < goods_data.sql
```

**修改hosts文件**

为了统一图片格式，我们修改了域名为image.meiduo.site

使用我们要在ubantu中修改

```
sudo vim /etc/hosts

127.0.0.1 www.meiduo.site
127.0.0.1 api.meiduo.site

192.168.216.137 image.meidu.site  # fastdfs地址
```



## 1.7 页面静态化

1. 在广告内容应用contents中，新建crons.py文件（该文件会用于后面讲解的定时任务），在该文件中编写处理页面静态化的逻辑。

```python
from collections import OrderedDict
from django.conf import settings
from django.template import loader
import os
import time

from goods.models import GoodsChannel
from .models import ContentCategory


def generate_static_index_html():
    """
    生成静态的主页html文件
    """
    print('%s: generate_static_index_html' % time.ctime())
    # 商品频道及分类菜单
    # 使用有序字典保存类别的顺序
    # categories = {
    #     1: { # 组1
    #         'channels': [{'id':, 'name':, 'url':},{}, {}...],
    #         'sub_cats': [{'id':, 'name':, 'sub_cats':[{},{}]}, {}, {}, ..]
    #     },
    #     2: { # 组2
    #
    #     }
    # }
    categories = OrderedDict()
    channels = GoodsChannel.objects.order_by('group_id', 'sequence')
    for channel in channels:
        group_id = channel.group_id  # 当前组

        if group_id not in categories:
            categories[group_id] = {'channels': [], 'sub_cats': []}

        cat1 = channel.category  # 当前频道的类别

        # 追加当前频道
        categories[group_id]['channels'].append({
            'id': cat1.id,
            'name': cat1.name,
            'url': channel.url
        })
        # 构建当前类别的子类别
        for cat2 in cat1.goodscategory_set.all():
            cat2.sub_cats = []
            for cat3 in cat2.goodscategory_set.all():
                cat2.sub_cats.append(cat3)
            categories[group_id]['sub_cats'].append(cat2)

    # 广告内容
    contents = {}
    content_categories = ContentCategory.objects.all()
    for cat in content_categories:
        contents[cat.key] = cat.content_set.filter(status=True).order_by('sequence')

    # 渲染模板
    context = {
        'categories': categories,
        'contents': contents
    }
    template = loader.get_template('index.html')
    html_text = template.render(context)
    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, 'index.html')
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(html_text)
```

2. 在settings配置文件中添加保存静态文件的目录

```python
# 生成的静态html文件，把重新渲染生成的Index页面上传到指定地方
GENERATED_STATIC_HTML_FILES_DIR = os.path.join(os.path.dirname(os.path.dirname(BASE_DIR)), 'front_end_pc')
```

3. 在meiduo_mall 中新建templates模板目录，在settings中配置模板目录

```shell
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # templates存放的位置 
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```



4. **把index.html文件添加到templates文件夹中**

   

5. shell 命令测试主⻚静态化

```
python manage.py shell
from contents.crons import generate_static_index_html
generate_static_index_html()
```







我们要它可以自动刷新，所以我们要用定时器功能

## 1.8 定时任务

对于首页的静态化，考虑到页面的数据可能由多名运营人员维护，并且经常变动，所以将其做成定时任务，即定时执行静态化。

在Django执行定时任务，可以通过django-crontab扩展来实现。

### 1.8.1 安装

```python
pip install django-crontab
```

### 1.8.2 在settings中注册

```python
INSTALLED_APPS = [
    ...
    'django_crontab',  # 定时任务
    ...
]
```

### 1.8.3 设置任务的定时时间(在settings中)

在配置文件中设置定时执行的时间

每个定时任务分为三部分定义：

- 任务时间

  ```shel
  基本格式 :
  
  * * * * *
  分 时 日 月 周      命令
  M: 分钟（0-59）。每分钟用*或者 */1表示
  H：小时（0-23）。（0表示0点）
  D：天（1-31）。
  m: 月（1-12）。
  d: 一星期内的天（0~6，0为星期天）。
  ```

- 任务方法

- 任务日志

首页的定时任务设置如下 在settings中

```python
# 定时任务
CRONJOBS = [
    # 每5分钟执行一次生成主页静态文件
    ('*/5 * * * *', 'contents.crons.generate_static_index_html','>>/Users/delron/Desktop/meiduo_mall/logs/crontab.log')
]  # 前面是系统自动执行那个地方的，后面是我们的log放执行日志的位置
```

### 1.8.4 解决中文字符问题

在定时任务中，如果出现非英文字符，会出现字符异常错误

可以通过在配置文件中添加定时任务执行的附加命令来实现

**1.settings模块中 **

```python
# 解决crontab中文问题
CRONTAB_COMMAND_PREFIX = 'LANG_ALL=zh_cn.UTF-8'
```

 2.静态html写⼊到⽂件时也要指定中⽂编码为utf-8

### 1.8.5 开启定时任务

添加定时任务到系统中

```shell
python manage.py crontab add
```

显示已经激活的定时任务

```shell
python manage.py crontab show
```

移除定时任务(测试完后一定要关闭不然会一直执行)

```shellv
python manage.py crontab remove
```



# ！2、商品界面静态化

```python
class GoodsCategoryAdmin(admin.ModelAdmin):
    """商品列内别模型站点管理类"""
    def save_model(self, request, obj, form, change):
        """
        当点击admin中保存按钮会调用此方法
        :param request: 保存本次请求对象
        :param obj: 本次要保存的模型对象
        :param form: admin中的表单
        :param change:
        :return:
        """
        obj.save()
        time.sleep(5)

    def delete_model(self, request, obj):
        """当admin点击删除时会调用此方法"""
        obj.delete()
在注册app中的admin进行定义
```

## 2.1 商品分类数据静态化

- 商品列表页中商品分类数据依然采用页面静态化技术展示。
- 商品列表页中商品分类数据的静态化由运营人员在编辑商品分类信息时触发生成静态化页面。
- 商品列表页中商品分类数据的页面静态化处理，我们选择使用异步任务类执行。

### 2.1.1 准备静态化异步任务

- 在celery_tasks中新建html/tasks.py任务

```python
from celery_tasks.main import celery_app
from django.template import loader
from django.conf import settings
import os

from goods.utils import get_categories


@celery_app.task(name='generate_static_list_search_html')
def generate_static_list_search_html():
    """
    生成静态的商品列表页和搜索结果页html文件
    """
    # 商品分类菜单
    categories = get_categories()

    # 渲染模板，生成静态html文件
    context = {
        'categories': categories,
    }

    template = loader.get_template('list.html')
    html_text = template.render(context)
    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, 'list.html')
    with open(file_path, 'w') as f:
        f.write(html_text)
```

- 在goods.utils.py文件中封装方法，获取商品分类菜单数据

```python
from collections import OrderedDict

from .models import GoodsChannel


def get_categories():
    """
    获取商城商品分类菜单
    :return 菜单字典
    """
    # 商品频道及分类菜单
    # 使用有序字典保存类别的顺序
    # categories = {
    #     1: { # 组1
    #         'channels': [{'id':, 'name':, 'url':},{}, {}...],
    #         'sub_cats': [{'id':, 'name':, 'sub_cats':[{},{}]}, {}, {}, ..]
    #     },
    #     2: { # 组2
    #
    #     }
    # }
    categories = OrderedDict()
    channels = GoodsChannel.objects.order_by('group_id', 'sequence')
    for channel in channels:
        group_id = channel.group_id  # 当前组

        if group_id not in categories:
            categories[group_id] = {'channels': [], 'sub_cats': []}

        cat1 = channel.category  # 当前频道的类别

        # 追加当前频道
        categories[group_id]['channels'].append({
            'id': cat1.id,
            'name': cat1.name,
            'url': channel.url
        })
        # 构建当前类别的子类别
        for cat2 in cat1.goodscategory_set.all():
            cat2.sub_cats = []
            for cat3 in cat2.goodscategory_set.all():
                cat2.sub_cats.append(cat3)
            categories[group_id]['sub_cats'].append(cat2)
    return categories
```

### 2.1.2 运营人员站点中触发异步任务

- 在goods.admin.py中，展示模型类数据，并触发异步任务

```python
from django.contrib import admin
from . import models

# Register your models here.


class GoodsCategoryAdmin(admin.ModelAdmin):
    def save_model(self, request, obj, form, change):
        obj.save()
        from celery_tasks.html.tasks import generate_static_list_search_html
        generate_static_list_search_html.delay()  # 保存之后，触发异步(把生成的模板渲染上去)

    def delete_model(self, request, obj):
        obj.delete()
        from celery_tasks.html.tasks import generate_static_list_search_html
        generate_static_list_search_html.delay()

admin.site.register(models.GoodsCategory, GoodsCategoryAdmin)
admin.site.register(models.GoodsChannel)
admin.site.register(models.Goods)
admin.site.register(models.Brand)
admin.site.register(models.GoodsSpecification)
admin.site.register(models.SpecificationOption)
admin.site.register(models.SKU)
admin.site.register(models.SKUSpecification)
admin.site.register(models.SKUImage
```



```
APIView只提供认证权限限流
GeneriAPIview提供了分页，过滤排序
```



# 3、商品界面的分页和排序

## 排序

### 1、视图

```python
from rest_framework.filters import OrderingFilter
from rest_framework.generics import ListAPIView

from .models import SKU
from .serializer import SKUSerializer


class SKUListView(ListAPIView):
    """商品列表数据查询"""

    serializer_class = SKUSerializer
    # queryset = ""  # 因为我们查询的时候要过滤条件 所以不能用all(), 所以我们就要重写get_queryset方法
    # 指定过滤器:需要指定排序后端
    filter_backends = (OrderingFilter,)  # ！！！可以看成加了一个标识，不加的话会报警告
    # 指定排序字段：搭配filter_backends使⽤的
    ordering_fields = ('create_time', 'price', 'sales')

    def get_queryset(self):
        """如果当前在视图中没有去定义get/post方法,那么就没法定义一个参数用来接收正则组提取出来url的参数，可以用视图函数中的args和kwargs"""
        category_id = self.kwargs.get('category_id')  # 没有pk的时候也可以用
        return SKU.objects.filter(is_launched=True, category_id=category_id)  # True是上架的商品，然后通过url传过来的id进行过滤
```

### 2、序列化器

```python
from rest_framework import serializers
from .models import SKU


class SKUSerializer(serializers.ModelSerializer):
    """sku商品序列化器"""

    class Meta:
        model = SKU
        fields = ['id', 'name', 'price', 'default_image_url', 'comments']
```

### 3、urls.py

```python
from django.conf.urls import url

from . import views

# 商品
urlpatterns = [
    # 商品查询列表
    url(r'^categories/(?P<category_id>\d+)/skus/', views.SKUListView.as_view()),
]

# 父类视图 url(r'^', include('goods.urls')),
```



## 分页

1. 先定义一个分页器

```python
# meiduo_mall.utils.pagination.py

from rest_framework.pagination import PageNumberPagination


class StandardResultsSetPagination(PageNumberPagination):
    """自定义分页"""
    page_size = 2 # 指定默认每页显示多少条数据
    page_size_query_param = 'page_size' # 前端用来指定显示第几页，查询关键字 默认就是page
    max_page_size = 20  # 最大显示多少条
```

2. 在settings中注册

```python
# DRF配置
REST_FRAMEWORK = {
 # 异常处理
 'EXCEPTION_HANDLER': 'meiduo_mall.utils.exceptions.exception_handler',
 # 认证
 'DEFAULT_AUTHENTICATION_CLASSES': (
 'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
 'rest_framework.authentication.SessionAuthentication',
 'rest_framework.authentication.BasicAuthentication',
 ),
 # 分⻚
 'DEFAULT_PAGINATION_CLASS': 'meiduo_mall.utils.pagination.StandardResultsSetPagination',
}
```

### 注意 pagination_class = None

```
因为我们改了默认的分页器，所以在向LiveAPIView也会使用新改的默认分页。
我们不想让它使用，所以可以用
pagination_class = None 禁用分页
```





# 4、商品详情界面静态化处理

站点类不能一耗时操作，所以我们用异步操作

## 4.1 实现静态化异步任务

- 在celery_tasks中新建html/tasks.py任务

```python
from celery_tasks.main import celery_app
from django.template import loader
from django.conf import settings
import os

from goods.utils import get_categories

from goods.models import SKU


@celery_app.task(name='generate_static_list_search_html')
def generate_static_list_search_html():
    """
    生成静态的商品列表页和搜索结果页html文件
    """
    # 商品分类菜单
    categories = get_categories()

    # 渲染模板，生成静态html文件
    context = {
        'categories': categories,
    }

    template = loader.get_template('list.html')
    html_text = template.render(context)
    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, 'list.html')
    with open(file_path, 'w') as f:
        f.write(html_text)




@app.task(name='generate_static_sku_detail_html')
def generate_static_sku_detail_html(sku_id):
    """
    生成静态商品详情页面
    :param sku_id: 商品sku id
    """
    # 商品分类菜单
    categories = get_categories()

    # 获取当前sku的信息
    sku = SKU.objects.get(id=sku_id)
    sku.images = sku.skuimage_set.all()

    # 面包屑导航信息中的频道
    goods = sku.goods
    goods.channel = goods.category1.goodschannel_set.all()[0]

    # 构建当前商品的规格键
    # sku_key = [规格1参数id， 规格2参数id， 规格3参数id, ...]
    sku_specs = sku.skuspecification_set.order_by('spec_id')
    sku_key = []
    for spec in sku_specs:
        sku_key.append(spec.option.id)

    # 获取当前商品的所有SKU
    skus = goods.sku_set.all()

    # 构建不同规格参数（选项）的sku字典
    # spec_sku_map = {
    #     (规格1参数id, 规格2参数id, 规格3参数id, ...): sku_id,
    #     (规格1参数id, 规格2参数id, 规格3参数id, ...): sku_id,
    #     ...
    # }
    spec_sku_map = {}
    for s in skus:
        # 获取sku的规格参数
        s_specs = s.skuspecification_set.order_by('spec_id')
        # 用于形成规格参数-sku字典的键
        key = []
        for spec in s_specs:
            key.append(spec.option.id)
        # 向规格参数-sku字典添加记录
        spec_sku_map[tuple(key)] = s.id

    # 获取当前商品的规格信息
    #specs = [
    #    {
    #        'name': '屏幕尺寸',
    #        'options': [
    #            {'value': '13.3寸', 'sku_id': xxx},
    #            {'value': '15.4寸', 'sku_id': xxx},
    #        ]
    #    },
    #    {
    #        'name': '颜色',
    #        'options': [
    #            {'value': '银色', 'sku_id': xxx},
    #            {'value': '黑色', 'sku_id': xxx}
    #        ]
    #    },
    #    ...
    #]
    specs = goods.goodsspecification_set.order_by('id')
    # 若当前sku的规格信息不完整，则不再继续
    if len(sku_key) < len(specs):
        return
    for index, spec in enumerate(specs):
        # 复制当前sku的规格键
        key = sku_key[:]
        # 该规格的选项
        options = spec.specificationoption_set.all()
        for option in options:
            # 在规格参数sku字典中查找符合当前规格的sku
            key[index] = option.id
            option.sku_id = spec_sku_map.get(tuple(key))

        spec.options = options

    # 渲染模板，生成静态html文件
    context = {
        'categories': categories,
        'goods': goods,
        'specs': specs,
        'sku': sku
    }

    template = loader.get_template('detail.html')
    html_text = template.render(context)
    file_path = os.path.join(settings.GENERATED_STATIC_HTML_FILES_DIR, 'goods/'+str(sku_id)+'.html')
    with open(file_path, 'w') as f:
        f.write(html_text)
```

## 4.2 准备相应的html和js

```
把list.html.detail.html放入templates文件夹中
```



## 4.3 异步任务的触发

运营人员在Admin站点保存商品信息时，应该触发生成商品静态页的异步任务。

我们需要调整Admin站点保存和删除商品信息时行为。

在Admin站点保存或删除数据时，Django是调用的Admin站点管理器类的**save_model()**方法和**delete_model()**方法，我们只需重新实现这两个方法，在这两个方法中调用异步任务即可。

编辑goods/admin.py

```python
from django.contrib import admin

from . import models


class SKUAdmin(admin.ModelAdmin):
    """商品模型站点管理类"""

    def save_model(self, request, obj, form, change):  # 管理员在点击保存在时候生效，调用生成静态页面
        obj.save()
        from celery_tasks.html.tasks import generate_static_sku_detail_html
        generate_static_sku_djintaietail_html.delay(obj.id)


class SKUImageAdmin(admin.ModelAdmin):
    def save_model(self, request, obj, form, change):
        obj.save()
        from celery_tasks.html.tasks import generate_static_sku_detail_html
        generate_static_sku_detail_html.delay(obj.sku.id)

        # 设置SKU默认图片
        sku = obj.sku  # 没有图片的话设置默认图片
        if not sku.default_image_url:
            sku.default_image_url = obj.image.url
            sku.save()

    def delete_model(self, request, obj):
        sku_id = obj.sku.id
        obj.delete()
        from celery_tasks.html.tasks import generate_static_sku_detail_html
        generate_static_sku_detail_html.delay(sku_id)


class SKUSpecificationAdmin(admin.ModelAdmin):
    def save_model(self, request, obj, form, change):
        obj.save()
        from celery_tasks.html.tasks import generate_static_sku_detail_html
        generate_static_sku_detail_html.delay(obj.sku.id)

    def delete_model(self, request, obj):
        sku_id = obj.sku.id
        obj.delete()
        from celery_tasks.html.tasks import generate_static_sku_detail_html
        generate_static_sku_detail_html.delay(sku_id)


# @admin.register(models.GoodsCategory)  方法创建好了，我们要标识是给那个类附加在有二个方法：1。@admin.register(models.GoodsCategory)  2。admin.site.register(models.GoodsCategory, GoodsCategoryAdmin)
class GoodsCategoryAdmin(admin.ModelAdmin):
    """管理员点击保存删除后，触发异步任务，生成页面"""
    def save_model(self, request, obj, form, change):
        """
        当点击admin中的保存按钮时会来调用此方法
        :param request:保存时文请求本次对象
        :param obj:本次要保存的模型对象
        :param form:admin中表单
        :param change:是否改为
        :return:
        """
        obj.save()
        from celery_tasks.html.tasks import generate_static_list_search_html
        # 重新生成静态页面
        generate_static_list_search_html.delay()

    def delete_model(self, request, obj):
        obj.delete()
        from celery_tasks.html.tasks import generate_static_list_search_html
        generate_static_list_search_html.delay()


#

# Register your models here.
admin.site.register(models.GoodsCategory, GoodsCategoryAdmin)  #
admin.site.register(models.GoodsChannel)
admin.site.register(models.Goods)
admin.site.register(models.Brand)
admin.site.register(models.GoodsSpecification)
admin.site.register(models.SpecificationOption)
admin.site.register(models.SKU, SKUAdmin)
admin.site.register(models.SKUSpecification, SKUSpecificationAdmin)
admin.site.register(models.SKUImage, SKUImageAdmin)

# 管理员对后台的数据进行操作后，触发异步任务，生成相应的页面
```



#### 触发异步任务的二种方式

```python
1。@admin.register(models.GoodsCategory)  # 装饰器
2。admin.site.register(models.GoodsCategory, GoodsCategoryAdmin) # 写入register
```



# 5、商品浏览记录保存分析

## 5.1 储存用户浏览记录

用户在访问每个商品详情页面时，都要记录浏览历史记录

历史记录只需保存多个商品的sku_id即可，而且需要保持添加sku_id的顺序，所以采用redis中的列表来保存，redis的数据存储设计

```python
'history_用户id': [sku_id列表]
```

```
lrem history:去重和python set一样
lpush history:把新的商品ID从前面插入  pop(0,id)
Ltrim：截取  【0:4】

lrem key conut value
	lrem key 2 3   key=[1,2,3,3] # 表示从key的开头查找3，去重二次
```



![18](E:\django项目资料\美多商城\项目笔记\img\18.png)



虚拟化器所在的类视图是GenericAPIView以及它的子类，里面有get_serializer

方法里面帮我们封装的

```python
  def get_serializer_context(self):
        """
        Extra context provided to the serializer class.
        """
        return {
            'request': self.request,
            'format': self.format_kwarg,
            'view': self
        }
```

### 5.1.1  View函数

```python
class UserBrowsingHistoryView(CreateAPIView):
    permission_classes = [IsAuthenticated]  # 登录的用户才可以访问
    serializer_class = AddUserBrowsingHistorySerializer
```

### 5.1.2 序列化

```python
class AddUserBrowsingHistorySerializer(serializers.Serializer): # 我们这里不能使用ModelSerializer，因为没有使用modes中的模型类，在加上ModelSerializer帮我们实现了create方法和存储位置。我们这里要存储在redis，使用不能用ModelSerializer
    sku_id = serializers.IntegerField(label="商品编号",min_value=1)  # 定义一个字段，方便接送前端传递过来的值

    def validate_sku_id(self,value):  # value=sku_id
        """校验商品id是否存在"""
        try:
            SKU.objects.get(id=value)
        except SKU.DoesNotExist:
            raise serializers.ValidationError("商品ID不存在")
		return value
    
    def create(self, validated_data):
        """
        存储在redis中，lrem去重，lpush从前面插入，Ltrim只取5个数据
        :param validated_data:
        :return:
        """
        user_id = self.context['request'].user.id # 获取当前用户的id（虚拟化器所在的类视图是GenericAPIView以及它的子类，里面有get_serializer方法里面帮我们封装的）
        sku_id = validated_data.get('sku_id')
        # 连接history的redis数据库
        redis_conn = get_redis_connection('history')
        pl = redis_conn.pipeline()  # 创建管道
        pl.lrem("history_%s"%user_id,0,sku_id)  # 去重 history_115 0 2  清除history_115中值为2的全部值 lrem key conut value
        pl.lpush('history_%s'%user_id,sku_id)  # 从头开始插入  lrem key value  value可以是多个
        pl.ltrim("history_%s" % user_id, 0,4)  # 5个
        pl.execute()  # 执行

        return validated_data
```

### 5.1.3 在settings中配置reids

```python
    "history": {  # redis保存浏览记录
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/3",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
```

### 5.1.4 url

```python
    # 商品浏览记录
    url(r'^browse_histories/$', views.UserBrowsingHistoryView.as_view()),
```



## 5.2 用户浏览记录查询redis

### 5.2.1 视图

**因为createAPIView是继承的GenericAPIView的里面有get和post等相关的方法，所以我们可以在这里面写get方法**

```python
class UserBrowsingHistoryView(CreateAPIView):
    permission_classes = [IsAuthenticated]  # 登录的用户才可以访问
    serializer_class = AddUserBrowsingHistorySerializer

    def get(self,request):  # 因为createAPIView是继承的GenericAPIView的里面有get和post等相关的方法，所以我们可以在这里面写get方法
        """
        查询商品的浏览记录
            从reids中查询出对应的id，然后通过id在SKU数据库，查询相应的商品信息
        """

        # 1. 创建reids连接
        redis_conn = get_redis_connection('history')
        # 2. 获取当前的请求用户
        user = request.user
        # 3. 获取redis中的数据
        sku_ids = redis_conn.lrange('history_%d'%user.id,0,-1)
        # SKU.objects.filter(id__in=sku_ids)  # 用此方法获取出来的是乱序的
        # 4. 遍历获取的id数据
        sku_list = []
        for sku_id in sku_ids:
            sku = SKU.objects.get(id=sku_id)  # 我们从redis获取出来的数据是一个bytes类型，但是在这里我们不用转换类型，因为在查询的时候会帮我们转换
            sku_list.append(sku)
        # 5.创建序列化进行校验输出
        serializer = SKUSerializer(sku_list,many=True)
        return Response(serializer.data)
```

### 5.2.2 序列化

```python
class SKUSerializer(serializers.ModelSerializer):
    """商品sku的序列化器，所以用ModelSerializer(有实际字段的用)"""

    class Meta:
        model = SKU
        fields = '__all__'
```

# 6.商品的全文搜索(Elasticsearch)

## 6.1 全文检索和Elasticsearch介绍

### 6.1.1 全文检索

1. like关键字

```python
MYSQL数据库的like关键字可以实现关键字搜索
	但是效率低下，涉及到多个字段不好实现
```

2. 全文检索

```
使⽤搜索引擎，在指定的任意字段中进⾏检索查询
```

3. 搜索引擎

```
通过搜索引擎进⾏数据查询时，搜索引擎并不是直接在数据库中进⾏查询，⽽是搜索引擎会对数据库中的数据进⾏⼀遍预处理，单独建⽴起⼀份索引结构数据。（类似于新华字典的首页⼀样的）
```

### 6.1.2 Elasticsearch介绍

```
1. 开源的 Elasticsearch 是⽬前全⽂搜索引擎的⾸选
2.它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采⽤它。
3.Elasticsearch 的底层是开源库 Lucene。
4.但是，你没法直接⽤ Lucene，必须⾃⼰写代码去调⽤它的接⼝。
5.Elastic 是 Lucene 的封装，提供了 REST API 的操作接⼝。
6.Elasticsearch 是⽤Java实现的。
7.注意点 Elasticsearch 不⽀持对中⽂进⾏分词建⽴索引，需要配合扩展elasticsearch-analysis-ik来实现中⽂分词处理。
```





## 6.2. 使用Docker安装Elasticsearch及其扩展(服务端)

在docker中安装并运行，（这里的是放在home文件夹下，一定要注意路径）
1. 先把 E:\django项目资料\美多商城\B站视频配套资料\Django阶段资料\美多商城项目-第10天\02-其他资料\搜索的配置文件及镜像 下的 elasticsearch-2.4.6 放到/home目录
![输入图片说明](https://images.gitee.com/uploads/images/2021/0720/215352_f09cc950_7998440.png "20.png")
2. 进入这个文件
![输入图片说明](https://images.gitee.com/uploads/images/2021/0720/215828_67962b00_7998440.png "21.png")
3. 修改ip地址(ubantu的本机ip)
修改elasticsearch的配置文件 elasticsearc-2.4.6/config/elasticsearch.yml第54行，更改ip地址为本机ip地址
```yml
network.host: 10.211.55.5   # TMD一定要记住ip前面有个空格
```
![输入图片说明](https://images.gitee.com/uploads/images/2021/0720/215903_753c2af8_7998440.png "22.png")
esc到一般模式  在:  wq 保存退出

4. 安装elasticsearch-ik:2.4.6-1.0
    1.获取镜像，可以通过网络pull
```shell
sudo docker image pull delron/elasticsearch-ik:2.4.6-1.0  # docker的安装命令
```
    2.或者加载提供给大家的镜像文件

```shell
sudo docker load -i elasticsearch-ik-2.4.6_docker.tar  # 加载镜像文件，
```
5. 安装配置好后运行并测试
elasticsearch-2.4.6配置ip  
elasticsearch-ik:2.4.6-1.0 安装好后
创建docker容器运行

```shell
sudo docker run -dti --network=host --name=elasticsearch -v /home/elasticsearch-2.4.6/config:/usr/share/elasticsearch/config delron/elasticsearch-ik:2.4.6-1.0
```

![输入图片说明](https://images.gitee.com/uploads/images/2021/0720/221006_dee6fdae_7998440.png "23.png")



## 6.3 配置haystack对接Elasticsearch(客户端)

### 6.3.1 安装haystack

```python
pip install drf-haystack
pip install elasticsearch==2.4.1
```

### 6.3.2 注册应用settings.py

```python
'haystack',
```

### 6.3.3 配置haystack

```python
# Haystack
HAYSTACK_CONNECTIONS = {
 'default': {
 'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',
 'URL': 'http://192.168.103.210:9200/', # 此处为elasticsearch运⾏的服务器ip地址，端⼝号固定为9200
 'INDEX_NAME': 'meiduo', # 指定elasticsearch建⽴的索引库的名称
 },
}
# 当添加、修改、删除数据时，⾃动⽣成索引
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor
```

**注意：**

**HAYSTACK_SIGNAL_PROCESSOR 的配置保证了在Django运行起来后，有新的数据产生时，haystack仍然可以让Elasticsearch实时生成新数据的索引**

## 6.4 创建索引类并⽣成索引数据(使用)

### 6.4.1 使⽤场景

```python
给商品模块的SKU模型类建⽴索引
goods.models.SKU
```

### 6.4.2 创建索引类

新建文件 **goods.search_indexes.py** （search_indexes是固定的）

通过创建索引类，来指明让搜索引擎对哪些字段建立索引，也就是可以通过哪些字段的关键字来检索数据。

在goods应用中新建search_indexes.py文件，用于存放索引类

```python
from haystack import indexes

from .models import SKU


class SKUIndex(indexes.SearchIndex, indexes.Indexable):
    """
    SKU索引数据模型类
    """
    text = indexes.CharField(document=True, use_template=True)

    def get_model(self):
        """返回建立索引的模型类(那个需要搜索的模型类)"""
        return SKU

    def index_queryset(self, using=None):
        """返回要建立索引的数据查询集(我们这里过滤了一下是否上架的商品)"""
        return self.get_model().objects.filter(is_launched=True)
```

### 6.4.3 在templates目录中创建text字段使用的模板文件

具体在templates/search/indexes/goods/sku_text.txt文件中定义

templates/search/indexes/{"试图名称"}/{"返回建立索引的模型类"}_test.txt

```python
templates/search/indexes/{"试图名称"}/{"返回建立索引的模型类"}_test.txt  # 其他的是固定的

{{ object.name }}  # sku模型类中，需要以哪几个字段进行搜索
{{ object.caption }}
{{ object.id }}
```

此模板指明当将关键词通过text参数名传递时，可以通过sku的name、caption、id来进行关键字索引查询。

### 6.4.4 手动生成初始索引

```python
python manage.py rebuild_index  # 第一次要手动生成下，后面会自动生成
```

### 6.4.5 创建序列化器

在goods/serializers.py中创建haystack序列化器

```python
from drf_haystack.serializers import HaystackSerializer
from rest_framework import serializers

from .models import SKU
from .search_indexes import SKUIndex


class SKUSerializer(serializers.ModelSerializer):
    """sku商品序列化器"""

    class Meta:
        model = SKU
        fields = ['id', 'name', 'price', 'default_image_url', 'comments']


class SKUSearchSerializer(HaystackSerializer):
    """
    SKU索引结果数据序列化器
    """
    object = SKUSerializer(read_only=True)  # 关联序列化，以SKUSerializer的字段进行输出显示

    class Meta:
        index_classes = [SKUIndex]
        fields = ('text', 'object')
```

##### 说明：

1. 下面的搜索视图使用SKUIndexSerializer序列化器用来检查前端传入的参数text，并且检索出数据后再使用这个序列化器返回给前端；

2. SKUIndexSerializer序列化器中的object字段是用来向前端返回数据时序列化的字段。

   Haystack通过Elasticsearch检索出匹配关键词的搜索结果后，还会在数据库中取出完整的数据库模型类对象，放到搜索结果的object属性中，并将结果通过SKUIndexSerializer序列化器进行序列化。所以我们可以通过声明搜索结果的object字段以SKUSerializer序列化的形式进行处理，明确要返回的搜索结果中每个数据对象包含哪些字段。

   如，通过上面两个序列化器，最终的返回结果形式如下：

   ```json
   [
       {
           "text": "华为 HUAWEI P10 Plus 6GB+128GB 钻雕蓝 移动联通电信4G手机 双卡双待\nwifi双天线设计！徕卡人像摄影！P10徕卡双摄拍照，低至2988元！\n11",
           "object": {
               "id": 11,
               "name": "华为 HUAWEI P10 Plus 6GB+128GB 钻雕蓝 移动联通电信4G手机 双卡双待",
               "price": "3788.00",
               "default_image_url": "http://image.meiduo.site:8888/group1/M00/00/02/CtM3BVrRdG6AYdapAAcPaeOqMpA1594598",
               "comments": 2
           }
       },
       {
           "text": "华为 HUAWEI P10 Plus 6GB+128GB 玫瑰金 移动联通电信4G手机 双卡双待\nwifi双天线设计！徕卡人像摄影！P10徕卡双摄拍照，低至2988元！\n14",
           "object": {
               "id": 14,
               "name": "华为 HUAWEI P10 Plus 6GB+128GB 玫瑰金 移动联通电信4G手机 双卡双待",
               "price": "3788.00",
               "default_image_url": "http://image.meiduo.site:8888/group1/M00/00/02/CtM3BVrRdMSAaDUtAAVslh9vkK04466364",
               "comments": 1
           }
       }
   ]
   ```

### 6.4.6 views.py视图函数

```python
from drf_haystack.viewsets import HaystackViewSet

class SKUSearchViewSet(HaystackViewSet):
    """
    SKU搜索
    """
    index_models = [SKU]  # 指定查询集(那个模型类)

    serializer_class = SKUSearchSerializer  # 指定序列化器
```

##### 注意：

- 该视图会返回搜索结果的列表数据，所以如果可以为视图增加REST framework的分页功能。
- 我们在实现商品列表页面时已经定义了全局的分页配置，所以此搜索视图会使用全局的分页配置。

### 6.4.7 定义路由

通过REST framework的router来定义路由

```python
from rest_framework.routers import DefaultRouter  # 注意导入的库


router = DefaultRouter()
router.register('skus/search', views.SKUSearchViewSet, base_name='skus_search')

urlpatterns += router.urls
```

### 6.4.8 测试

我们可以GET方法访问如下链接进行测试

```http
http://127.0.0.1:8000/skus/search/?text=华为

http://127.0.0.1:8000/skus/search/?text={搜索的名字}    # 和百度的wb一样
```

#### bug说明：

如果在配置完haystack并启动程序后，出现如下异常，是因为drf-haystack还没有适配最新版本的REST framework框架

![haystack异常](../images/get_count异常.png)

可以通过修改REST framework框架代码，补充`_get_count`函数定义即可

文件路径 虚拟环境下的 `lib/python3.6/site-packages/rest_framework/pagination.py`
```python
def _get_count(queryset):
    """
    Determine an object count, supporting either querysets or regular lists.
    """
    try:
        return queryset.count()
    except (AttributeError, TypeError):
        return len(queryset)
```